from dataparse import getdisimport numpy as npimport randomfrom time import timeclass localsearch:    def __init__(self, city, seedNo, time_limit):        self.distances = np.array(getdis("./DATA/"+city+".tsp"))        self.route = np.arange(len(self.distances)-1)        self.seedNo = seedNo        random.seed(seedNo)        random.shuffle(self.route)        self.route = self.route + 1        self.route = np.insert(self.route, 0, 0)        self.route = np.append(self.route, 0)        self.cost = 0        self.computeCost()        self.time_limit = time_limit        self.start_time = 0        self.time = 0        self.city = city        self.trace_time = np.array([])        self.trace_cost = np.array([])        self.seedNo = seedNo    def opt2(self):        count = 0        improved = False        while(~improved and count < 1000000):            improved = False            for i in range(len(self.route)-1):                for k in range(len(self.route)-i-3):                    j = i + 2 + k                    diff = self.distances[self.route[i]][self.route[i + 1]] + self.distances[self.route[j]][self.route[j+1]] - self.distances[self.route[i]][self.route[j]] - self.distances[self.route[j+1]][self.route[i+1]]                    if(diff > 0):                        improved = True                        self.swap(i+1, j)                        self.cost -= diff                        runtime = time() - self.start_time                        self.trace_time = np.append(self.trace_time, runtime)                        self.trace_cost = np.append(self.trace_cost, int(self.cost))                    if(time()-self.start_time>self.time_limit):                        return            count += 1        # self.time = time() - self.start_time    def swap(self, i, j):        while i < j:            temp = self.route[i]            self.route[i] = self.route[j]            self.route[j] = temp            i += 1            j -= 1    def getRoute(self):        return self.route    def computeCost(self):        sum = 0        for i in range(len(self.route)-1):            sum += self.distances[self.route[i]][self.route[i+1]]        self.cost = sum    def getCost(self):        return self.cost    def getTime(self):        return self.time    def write_sol(self):        cost = (str)((int)(self.cost))        with open('./output/'+self.city + '_ls1_' + str(self.time_limit) + '.sol', 'w') as f:            f.write(cost)            f.write('\n')            for i in range(len(self.route)-1):                f.write('{} {} {}\n'.format(self.route[i], self.route[i+1], int(self.distances[self.route[i]][self.route[i+1]])))    def write_trace(self):        with open('./output/'+self.city + '_ls1_' + str(self.time_limit)+'_' + str(self.seedNo) +'.trace', 'w') as f:            for i in range(len(self.trace_cost)):                f.write('{:.2f} {}\n'.format(self.trace_time[i], str(int(self.trace_cost[i]))))    def main(self):        self.start_time = time()        self.opt2()        self.time = time() - self.start_time        result = self.getRoute()        cost = self.getCost()        # self.write_sol()        # self.write_trace()if __name__ == '__main__':    # cities = ["Atlanta", "Berlin", "Boston", "Champaign", "Cincinnati", "Denver", "NYC", "Philadelphia", "Roanoke", "SanFrancisco", "Toronto", "UKansasState", "ulysses16","UMissouri"]    # for city in cities:    #     ls = localsearch(city, 1, 600)    #     ls.main()    costs = np.array([])    times = np.array([])    for i in range(3):        n = random.randint(1, 100)        ls = localsearch("Atlanta", n, 20)        ls.main()        costs = np.append(costs, ls.getCost())        times = np.append(times, ls.getTime())    print(costs)    print(times)